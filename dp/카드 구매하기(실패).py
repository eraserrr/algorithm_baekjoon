# N개의 카드를 구매하기 위해서는 N을 이룰 수 있는 모든 조합을 계산해 봐야 한다.

# 처음에는 한장당 효율이 좋은(비싼) 카드를 많이 구매할 수록 좋다고 생각했는데, 
# 그렇지는 않다. 반례로는 [1 9 30 44 10], [1 2 6 8 11 1 1 1 1 1 1 1] 이 있다.

# 1. [1 18 30 44 10]
# 이 경우는 4개 팩이 가장 효율이 좋다. 그래서 4팩을 구매했다가는 44+1 -> 45 원이다.
# 그런데 30+18 -> 48 이 정답이다.

# 2. [1 2 6 8 11 1 1 1 1 1 1 1]
# 이 경우는 효율이 좋은 팩을 최대로 계산했다가는 11*2 + 2 -> 24이다.
# 하지만 답은 1팩, 3팩, 4팩, 5팩을 구매한 6+8+11+1이.

# 모든 경우의 수를 다 구해봐야 한다고 했던 것이 이런 이유이다.

# 그럼 2번 반례를 예시로 카드 구매 개수에 따른 모든 경우의 수를 구해보자.

# 1개 구매 : 1팩(1) --> 1 
#     1(팩)
# 2개 구매 : 1팩+1팩 , 2팩(2)  --> 2
#     1+1 , 2
# 3개 구매 : 1팩+1팩+1팩(3), 1팩+2팩(3), 3팩(6) --> 6
#     1+1+1, 1+2, 3
# 4개 구매 : 1팩+1팩+1팩+1팩(4), 1팩+1팩+2팩(4), 1팩+3팩(7), 2팩+2팩, 4팩(8) --> 8
#     1+(1+1+1), 1+(1+2), 1+(3), 2+(2), 2+(1+1), 3+(1), 4
# 5개 구매 : 1팩+1팩+1팩+1팩+1팩, 1팩+1팩+1팩+2팩(5), 1팩+1팩+2팩(5), ......

# 이 때, 연산 중 겹치는 계산을 찾을 수 있다
# n 개구매에서, 모든 경우의 수는 
# 1+(N-1의 덧셈 조합) , 2+(N-2의 덧셈조합) , 3+(N-3의 덧셈조합)..... ,  N+(N-N의 덧셈조합) 으로 나타내진다
# 따라서 미리 계산한 값을 메모이제이션하여 계산양을 줄일 수 있다.

# 1개 구매 : pack[1]
# 2개 구매 : 1+ dp[1], 2+dp[0]
# 3개 구매 : 1+ dp[2], 2+dp[1], 3+dp[0]
# 4개 구매 : 1+ dp[3], 2+dp[2], 3+dp[1], 4+dp[0] 

# 이것을 코드로 하면

N = int(input())
pack = [0] + list(map(int,input().split()))
dp = [0] *(N+1)
dp[1] = pack[1]

for i in range(1, N+1):
    x = []
    for j in range(1, i+1):
        x.append(pack[j] + dp[i-j])
    dp[i] = max(x)

print(dp)
